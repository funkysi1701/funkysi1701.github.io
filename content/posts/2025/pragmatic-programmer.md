+++
title = "The Pragmatic Programmer"
date = "2025-02-24T20:00:00Z"
year = "2025"
month= "2025-02"
author = "funkysi1701"
authorTwitter = "funkysi1701" #do not include @
cover = "/images/tpp.jpg"
images =['/images/tpp.jpg']
tags = ["Pragmatic Programmer", "Book Review", "Programming", "Software Development", "Best Practices", "Tech"]
category="tech"
description = "'The Pragmatic Programmer' with key takeaways and tips for improving your programming skills and practices."
showFullContent = false
readingTime = true
copyright = false
featured = false
draft = false
aliases = [
    "/pragmatic-programmer",
    "/posts/pragmatic-programmer",
    "/posts/2025/02/24/pragmatic-programmer",
    "/2025/02/24/pragmatic-programmer" 
]
+++
I have been reading [The Pragmatic Programmer](https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/) and I have to say it is a fantastic book. It is full of great advice and tips for programmers. I highly recommend it to anyone who is a programmer at any level.

Lots of the advice is common sense and things I already do, but there are also lots of things I know in the back of my mind that I should be doing. So reading it has been a great reminder of those things.

Here is the complete list of tips that can be found in the book (I am reading the 20th anniversary edition, so these might be slightly different if you are looking at the original edition):

1. Care About Your Craft
2. Think! About Your Work

### A Pragmatic Philosophy

3. You Have Agency
4. Provide Options, Don’t Make Lame Excuses
5. [Don’t Live with Broken Windows](/posts/2015/pragmatic-programmer-broken-windows/) (I blogged about this in 2015)
6. Be a Catalyst for Change
7. Remember the Big Picture
8. Make Quality a Requirements Issue
9.  Invest Regularly in Your Knowledge Portfolio
10. Critically Analyze What You Read and Hear
11. English is Just Another Programming Language
12. It’s Both What You Say and the Way You Say It
13. Build Documentation In, Don’t Bolt It On

### A Pragmatic Approach

14. Good Design Is Easier to Change Than Bad Design
15. DRY - Don’t Repeat Yourself
16. Make It Easy to Reuse
17. Eliminate Effects Between Unrelated Things
18. There Are No Final Decisions
19. Forgo Following Fads
20. Use Tracer Bullets to Find the Target
21. Prototype to Learn
22. Program Close to the Problem Domain
23. Estimate to Avoid Surprises
24. Iterate the Schedule with the Code

### The Basic Tools

25. Keep Knowledge in Plain Text
26. Use the Power of Command Shells
27. Achieve Editor Fluency
28. Always Use Version Control
29. Fix the Problem, Not the Blame
30. Don’t Panic
31. Failing Test Before Fixing Code
32. Read the Damn Error Message
33. "select" Isn't Broken
34. Don't Assume It - Prove it
35. Learn a Text Manipulation Language

### Pragmatic Paranoia

36. You Can't Write Perfect Software
37. Design with Contracts
38. Crash Early
39. Use Assertions to Prevent the Impossible
40. Finish What You Start
41. Act Locally
42. Take Small Steps - Always
43. Avoid Fortune Telling

### Bend, or Break

44. Decoupled Code is Easy to Change
45. Tell, Don't Ask
46. Don't Chain Method Calls
47. Avoid Global Data
48. If it's Important Enough to be Global, Wrap It in an API
49. Programming is About Code, But Programs Are About Data
50. Don't Hoard State; Pass It Around
51. Don't Pay Inheritance Tax
52. Prefer Interfaces to Express Polymorphism
53. Delegate to Services: Has-A Trumps Is-A
54. Use Mixins to Share Functionality
55. Parameterize Your App Using External Configuration

### Concurrency

56. Analyze Workflow to Improve Concurrency
57. Shared State is Incorrect State
58. Random Failures Are Often Concurrency Issues
59. Use Actors for Concurrency Without Shared State
60. Use Blackboards to Coordinate Workflow

### While You Are Coding

61. Listen to Your Inner Lizard
62. Don't Program by Coincidence
63. Estimate the Order of Your Algorithms
64. Test Your Estimates
65. Refactor Early, Refactor Often
66. Testing is Not About Finding Bugs
67. A Test is the First User of Your Code
68. Build End-to-End, Not Top-Down or Bottom-Up
69. Design To Test
70. Test Your Software, or Your Users Will
71. Use Property-Based Tests to Validate your Assumptions
72. Keep it Simple and Minimize Attack Surfaces
73. Apply Security Patches Quickly
74. Name well; Rename When Needed

### Before the Project

75. No One Knows Exactly What They Want
76. Programmers Help People Understand What They Want
77. Requirements are Learned in a Feedback Loop
78. Work with a User to Think Like a User
79. Policy is Metadata
80. Use a Project Glossary
81. Don't Think Outside the Box - Find the Box
82. Don't Go into the Code Alone
83. Agile is Not a Noun; Agile is How You Do Things

### Pragmatic Projects

84. Maintain Small, Stable Teams
85. Schedule It to Make it Happen
86. Organize Fully Functional Teams
87. Do What Works, Not What's Fashionable
88. Deliver When Users Need It
89. Use Version Control to Drive Builds, Tests and Releases
90. Test Early, Test Often, Test Automatically
91. Coding Ain't Done 'Til All the Tests Run
92. Use Saboteurs to Test Your Testing
93. Test State Coverage, Not Code Coverage
94. Find Bugs Once
95. Don't use Manual Procedures
96. Delight Users, Don't Just Deliver Code
97. Sign your Work

### 

98.  First, Do No Harm
99. Don't Enable Scumbags
100. It's Your Life

